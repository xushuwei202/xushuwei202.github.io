<!DOCTYPE HTML>
<html>
<head>
	<title>gift-animate</title>
	<meta charset="utf-8">
	<meta name="viewport" content="initial-scale=1 maximum-scale=1 user-scalable=0" />
	<style>
		html,body{
			height: 100%;
		}
		body {
			position: relative;
			margin: 0;
			padding: 0;
			background-color: #fff;
		}

		button{
			position: absolute;
			z-index: 10;
		}

		#photonstorm {
			position: absolute;
			bottom: 16px;
			right: 16px;
		}

		#pixi {
			position: absolute;
			bottom: 16px;
			left: 16px;
		}

		canvas {
			width: 100%;
			height: 100%;
			background-color: #000;
		}

	</style>
	<script src="jquery-1.8.3.min.js"></script>
	<script src="pixi.min.js"></script>
	<script src="physicsjs-full.min.js"></script>


	<script type="text/javascript">//<![CDATA[
		$(window).load(function(){
		
		Physics(function(world){

			var ua = navigator.userAgent;
			var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
		    var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
		    var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
		    var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);

		    var isWebView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);

		    var options = {
			    gravityFactor: 1,
			    warp: 1,
			    renderSteps: 1,
			    ballNum : 100
			};
			if (isWebView || android) {
			    options = {
			        gravityFactor: 1,
			        warp: 1,
			        renderSteps: 1,
			        ballNum: 50
			    };
			}

		    var viewWidth = $(window).width();
		    var viewHeight = $(window).height();
		    var renderer = Physics.renderer('pixi', {
		        el: 'viewport',
		        width: viewWidth,
		        height: viewHeight,
		        meta: false
		    });
		    

		    world.add( renderer );

		    var stepNo = 0;
		    world.on('step', function(){
		        ++stepNo;
			    if (stepNo % options.renderSteps === 0) {
			        world.render();
			    }
		    });
		    

		    var viewportBounds = Physics.aabb(0, 0, viewWidth, viewHeight);

		   	world.add([
			    Physics.behavior('edge-collision-detection', {
			    	aabb: viewportBounds,
		        	restitution: 0.99,
		        	cof: 0.99
		        }),
			    Physics.behavior('body-collision-detection',  { el: renderer.container }),
			    Physics.behavior('body-impulse-response'),
			    Physics.behavior('sweep-prune'),
			    renderer
			]);

		   	var gravityY = 0.0004;
			var gravity = Physics.behavior('constant-acceleration', {
			    acc: { x : 0, y: gravityY * options.gravityFactor }
			});
			world.add( gravity );

			world.warp(options.warp);

		    Physics.body('wheel', 'circle', function( parent ){
		        return {
		            spin: function( speed ){
		                this.state.angular.vel = speed;
		            }
		        };
		    });


		    var lastTime = new Date().getTime(),
		    	curTime = lastTime;
		    var wheelArr = [];

		    var ballindex = 0;
		    Physics.util.ticker.on(function( time, dt ){
		    	curTime = new Date().getTime();
		    	if(curTime - lastTime >= 70) {
		    		var left = false;
		    		if(ballindex % 2 == 0) {
		    			left =  true;
		    		}

		    		ballindex++;
		    		createBall(left);

		    		if(wheelArr.length >= options.ballNum) {
		    			world.remove(wheelArr.shift());
		    		}
		    		lastTime = curTime;
		    	}

		        world.step( time );
		    });

		    function createBall (left) {
		    	var myWheel = null;
		    	var  x = 0;
		    	var flag = 1;
		    	if(!left) {
		    		x = viewWidth;
		    		flag = -1;
		    	}

		   		var  y = screen.height * 0.2;
		   		myWheel = Physics.body('wheel', {
			        x: x,
			        y: y,
			        vx:  Math.random() * flag * 0.4,
			        mass: 50,
			        restitution: 0.5,
			        radius: 8.5 
			    });

			    myWheel.view = renderer.createDisplay('sprite', {
				    texture: 'assets/star.png',
				    anchor: {
				        x: 0.5,
				        y: 0.5
				    }
				});


		   		wheelArr.push(myWheel);
			    world.add( myWheel );
		    }
		    

		    Physics.util.ticker.start();
		    if (window.DeviceOrientationEvent) {
		        window.ondeviceorientation = function (event) {

		            var pitch = Math.PI * event.beta / 180;
		            var roll = Math.PI * event.gamma / 180;

		            var acc = {
		                x: Math.cos(pitch) * Math.sin(roll) * gravityY,
		                y: Math.sin(pitch) * gravityY
		            };

		            world.one('step', function () {
		                gravity.setAcceleration(acc);
		            });
		        };
		        
		    }
		    
		});
		});

		</script>
</head>
<body>
	<div id="viewport" style="text-align: center;"></div>
</body>
</html>
